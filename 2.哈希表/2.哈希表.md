# 2.哈希表

```C++
// -*- coding: utf-8 -*-
// @Author  	: quanchenliu
// @Time	   	: 2024/1/27
// @Function	: 哈希表
```

## 一、章节概述

哈希表是一种使用哈希函数组织数据，以**支持快速插入和搜索**的数据结构。有两种不同类型的哈希表：**哈希集合**和哈希映射。

- 哈希集合：集合的实现方式之一，用于**存储非重复值**。
- 哈希映射：映射的实现之一，用于存储键值对 (key, value) 。

​		在标准模板库（STL）的帮助下，哈希表是易于使用的。大多数常见语言（如 Java，C ++ 和 Python）都支持哈希集合和哈希映射。通过选择合适的哈希函数，哈希表可以在插入和搜索方面展现出 出色的性能。在本 章节 中，我们将回答以下问题：

- [ ] 哈希表的原理是什么？

- [ ] 如何设计哈希表？如何解决**哈希冲突**？
- [ ] 如何使用哈希集合解决与**重复元素相关**的问题？
- [ ] 如何使用哈希映射解决与**滑动窗口相关**的问题？
- [ ] 如何在使用哈希表时设计正确的键？



## 二、哈希表概述

### 1、哈希表概述：

​		哈希表是一种使用哈希函数组织数据的数据结构，它支持快速插入和搜索；它根据关键字直接访问的**数据结构**；建立了关键字与存储地址之间的**直接映射关系**；

### 2、哈希表的原理：

​		哈希表（又称散列表）的原理为：借助 哈希函数，将键映射到存储桶地址。

​		更确切地说，首先开辟一定长度的，具有连续物理地址的桶数组；当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；当我们想要搜索一个键时，哈希表将使用哈希函数来找到对应的桶，并在该桶中进行搜索。

### 3、装填因子$α$：

​		装填因子，是哈希表的一个重要参数，它**反映了哈希表的装满程度**。

​		在实际的应用中，我们会发现有的桶处于空闲状态，而有的桶产生了**哈希冲突**，如何解决这个问题呢？不难想到，哈希函数是导致冲突的原因之一，更进一步，如果我们**增加桶的数量**，再采用合适的哈希函数，可使发生冲突的可能性大大减小。

​		然而，桶的个数太多则会造成大量的空间浪费。比如一个公司的电话号码共有 10 个，每个电话号码是 00000000 到 99999999 内的任意八位数字，如果我们想到一种方案，将每个可能的电话号码作为一个桶，使得电话号码与桶一一对应，则一共需要创建 $10^8$  个桶。

​		**实际利用桶的个数与桶的总数的比值**，称为装填因子。在这个实例中，负载因子太小甚至接近于 0，这样的方案显然是不现实的。**比较合理的装填因子是 0.7**，如果数据量是 7，则会创建 10 个桶，以此类推。随着插入的数据量的增加，计算机会逐渐增加桶的个数，并选择合适的哈希函数，使得数据经过映射之后能均匀地分布在桶中。

### 4、哈希函数：

哈希函数是哈希表中最重要的组件，用于**将键映射到特定的桶**。一个好的哈希函数，应当具备以下几个特点：

- 哈希函数的键与桶的对应关系具有确定性。也就是说，对于 key 所映射的桶地址，只由 key 键本身决定，而不由其他因素决定；

- 哈希函数不应太过复杂。太过于复杂的哈希函数将导致计算桶地址不能快速完成，从而无法快速定位桶；

- 映射结果的分布应具有均匀性。对于特定的桶空间，我们应尽量保证数据经过哈希函数映射之后，能够均匀地分布在桶的整个地址空间中。


![image-20240127150155033](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20240127150155033.png)

### 5、哈希函数构造方法：

**（1）直接定址法：**                               

​			①以关键字的线性函数值作为哈希地址；   

​			②计算最简单，**不会产生冲突**，适合关键字**稠密**（关键字分布基本连续）的情况；

​			③实际中很少应用；

**（2）数字分析法：**

​			①对关键字进行分析，取关键字的若干位或组合作为哈希地址；

​			②适用于关键字位数比哈希地址位数大，且可能出现的关键字事先知道；

​			③可以尽量选取数码分布均匀的位；

**（3）平方取中法：**

​			①取关键字的平方值的中间几位作为哈希地址；

​    		②适用于不知道全部关键字的情况，较为常用；

**（4）折叠法：**

​			①将关键字分割成**位数相同**的几部分，然后取这几部分的**叠加和**作为哈希地址；

​			②移位叠加：将分割后的几部分**低位对齐**相加；

​			③间界叠加：从一端到另一端沿分割界**来回折叠**，然后对齐相加；

**（5）除留余数法：**

​			①最简单、**最常用**；

​			②哈希表表长为m，取一个不大于m但最接近或等于m的质数p：
$$
Hash(key)=key\  \% \ p，
$$


### 6、冲突解决方法：

​		由于任何哈希函数都不可能绝对避免冲突，因此必须考虑如何处理冲突，即：为产生冲突的关键字寻找下一个“空”的Hash地址。

**（1）开放地址法：**可存放新表项的空闲地址**既向同义词开放，又向非同义词开放**；递推关系如下：
$$
H_i=(Hash(key)+d_i)\ \% \ m
$$
**①线性探测法**：当  时，称为线性探测法。当冲突发生时，顺序查看表中的下一单元直至找到一个空闲单元或查遍全表。

- 优点：只要散列表未满，总能找到一个不冲突的哈希地址；
- 缺点：造成大量元素在相邻的哈希地址上“**聚集**”（或堆积），增加了更多的冲突机会。

**②平方探测法**：当  时，称为平方探测法。

- 优点：跳跃式散列到整个表中，不易发生“聚集”；
- 缺点：**不能探测到所有单元，但至少能探测到一半**；

**③双散列法**：构造若干个哈希函数，当发生冲突时，利用不同的哈希函数在计算下一个新哈希地址；即：
$$
H_i=Hash_i (key)\ * \ R
$$
**④伪随机序列法：**增量序列使用一个伪随机数来产生一个落在闭区间[1，m-1]的随机序列



**（2）链接法：**将所有的同义词存储在一个单链表中，并用一维数组存放链表头指针；

## 三、构造哈希集合与哈希映射







## 七、类与对象

### 1、类的声明与对象的定义：

#### （1）类和对象的关系：

​		类是对象的抽象，对象是类的具体实例。

#### （2）声明类类型：

​		在C++中，声明一个类类型，其方法和声明一个结构体类型是相似的。

#### （3）定义对象的方法：

​		①先声明类类型，然后定义对象：		`Student stud1;				// Student 是已经声明的类`

​		②在声明类的同时定义对象：

### 2、利用构造函数对类对象进行初始化：

​		在定义对象的同时，我们也需要完成**对象的初始化**工作，即：对数据成员赋初值。**注意：**不能在类声明中对数据成员初始化。

​		如果一个类中的所有成员都是**公用的（public）**，则可以在定义对象时对数据成员进行初始化工作；如果数据成员有私有的，或者类中有private/protected的数据成员，就不能用这种方法初始化。

#### （1）利用构造函数完成初始化：

​		C++提供了构造函数（constructor）来处理对象的初始化。构造函数是一种特殊的成员函数，它**无需用户调用，而是在建立对象时自动执行**。构造函数是声明类的时候由程序员定义的，**程序用户只需在定义对象的同时指定数据成员的初值即可**。

​		构造函数的名字必须与类名同名（不能任意命名），它不具有任何类型，不返回任何值，也不能被用户调用。但是，我们可以用一个类对象去初始化另一个类对象。

​		如果程序员没有定义构造函数，则C++系统会生成一个空的构造函数，不执行任何操作。

#### （2）带参数的构造函数：

​		当我们希望**对不同的对象赋予不同的初值**时，上面的方法就无法实现了，我们可以采用带参数的构造函数，以实现多样化的初始化。

**构造函数的首部一般格式为**：

```C++
构造函数名（类型1 形参1，类型2 形参2，...）
```

**定义对象的一般格式为：**

```C++
类名 对象名（实参1，实参2，...)		// 构造函数不能被调用，因此在定义对象时给出实参
```

### 3、析构函数：

​		析构函数是与构造函数功能相反的函数。在对象生命周期结束时，会自动执行析构函数。析构函数的作用并不是删除对象，而是**在撤销对象占用的内存之前完成一些清理工作**，也可以执行“**用户希望在最后一次使用对象之后所执行的任何操作**”。一个类可以有多个构造函数，但只能有一个析构函数。

























